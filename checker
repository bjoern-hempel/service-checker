#!/bin/bash

# include the libraries
filename=$(readlink ${BASH_SOURCE[0]})
root=$(dirname "$filename")
source "$root/lib/all"
source "$root/functions"

# date (log file usage)
dateFile=$(date +%Y-%m-%d_%H%M%S)

# some params
CONFIG_ENVIRONMENT_FOLDER='/etc/service-checker'
  CONFIG_ENVIRONMENT_FILE='environments.conf'
     TMP_CONTENT_LOG_FILE="/tmp/service-checker.${dateFile}.log"
       EMAIL_FROM_ADDRESS="monitoring@dd3.rsm-development.de"
          EMAIL_TIME_FILE="/etc/service-checker/email.conf"
                 INI_FILE="$root/config.ini"

# create ini file if not exists
if [ ! -f "$INI_FILE" ]; then
    touch "$INI_FILE"
fi

# get parent command
parentCommand="$(ps -o comm= $PPID)"
[ "$parentCommand" == "bash" ] && directCall=true || directCall=false

# is running check only for direct calls, otherwise ignore this
if $directCall; then
    # check running status
    scriptIsRunning=$(getCachedValue "$INI_FILE" scriptIsRunning false)

    # script is already running
    if $scriptIsRunning; then
        echo "Script is already running. Abort.."
        exit
    fi

    # set running flag
    setCachedValue "$INI_FILE" scriptIsRunning true
fi

# start environment loader
environmentLoader "$0" "$@"
lastStatus=$?

# environment loader was used. Stop here.
if [ $lastStatus -gt 0 ]; then
    ((lastStatus--))
    setCachedValue "$INI_FILE" scriptIsRunning false
    exit $lastStatus
fi

# output settings
resetOutputVars 50
setOutputContentType "log:stdout"

# include other libraries
source "$root/parameter"

if [ "$emailAddress" != "" ]; then
    setOutputContentType "log:>${TMP_CONTENT_LOG_FILE}"
fi

# save the ip address
ip="${PARAMETERS[0]}"

allPassed=true

# check if server is running
if isPingableCheck "$ip"; then
    pingable=true
else
    allPassed=false
fi

# check positive ports
for port in "${portsPositive[@]}"; do
    if ! isPortOpenCheck "$ip" "$port"; then
        allPassed=false
    fi
done

# check negative ports
for port in "${portsNegative[@]}"; do
    if ! isNotPortOpenCheck "$ip" "$port"; then
        allPassed=false
    fi
done

# a record check
for domain in "${!aRecords[@]}"; do
    if ! isDomainAssignedToIpCheck "$domain" "$ip" true; then
        allPassed=false
    fi
done

# status code check
statusCodeCounter=0
for url in "${!statusCodeCheck[@]}"; do
    ports="${statusCodeCheck[$url]}"

    if ! isHttpStatusCodeCheck "$url" "$ports"; then
        allPassed=false
    fi
done

# ssl check
for domain in "${sslCheck[@]}"; do
    certFile="/tmp/$domain.crt"
    chainfile="/tmp/$domain.ca"

    # get and save domain cert
    cert=$(getDomainCert "$domain")
    echo "$cert" > "$certFile"

    # get the issuer from domain cert
    issuer=$(getIssuer "$domain")

    # get and save the issuer certificate
    certChain=$(getChainCertificate "$domain")
  
    if [ "$certChain" == "" ]; then
        outputContent "domains.${domain}.certificate" "failed" "No chain certificate returned."
        allPassed=false
    else
        echo "$certChain" > "$chainfile"

        # check the certificates
        if ! isCertificateVerified "$certFile" "$chainfile" "$domain"; then
            allPassed=false
        fi
        if ! isChainCertificateVerified "$chainfile" "$issuer" "$domain"; then
            allPassed=false
        fi
        if ! isCertificateValid "$certFile" "$domain"; then
            allPassed=false
        fi
        if ! isDomainFromCertificate "$domain" "$certFile"; then
            allPassed=false
        fi

        # gets the status
        if ! isStatusOcspOk "$domain" "$chainfile" "$certFile"; then
            allPassed=false
        fi
    fi
done

# print all check status
if $allPassed; then
    exitType="passed"
    exitText="All checks passed."
    exitStatus=0
else
    exitType="failed"
    exitText="At least one check is not passed."
    exitStatus=1
fi

# print the last message (summary message)
outputContent "overall" "$exitType" "$exitText"
outputFinish

# send email if log file is available and email address given
if [ -f "$TMP_CONTENT_LOG_FILE" ]; then
#    if [ "$emailAddress" != "" ]; then
#        emailContent=$(cat "$TMP_CONTENT_LOG_FILE")
#        sendMails "$exitText" "$emailContent" "$emailAddress" "$EMAIL_FROM_ADDRESS" "$EMAIL_TIME_FILE" 10
#    fi
    rm "$TMP_CONTENT_LOG_FILE"
fi

exit $exitStatus
